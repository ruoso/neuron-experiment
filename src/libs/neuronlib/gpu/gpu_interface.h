#ifndef NEURONLIB_GPU_INTERFACE_H
#define NEURONLIB_GPU_INTERFACE_H

#include <cstdint>
#include <cstddef>

namespace neuronlib {
namespace gpu {

// Maximum batch sizes for GPU processing - can be tuned based on GPU memory
constexpr size_t MAX_GPU_TARGETS = 4096;           // Max target addresses per batch
constexpr size_t MAX_GPU_ACTIVATIONS = 16384;      // Max total activations per batch
constexpr size_t MAX_GPU_OUTPUTS = 32768;          // Max output activations per batch
constexpr size_t MAX_GPU_WEIGHT_UPDATES = 8192;    // Max weight updates per batch

// Input batch for GPU processing - statically sized for GPU efficiency
struct GpuActivationBatch {
    // Number of items actually used (runtime size)
    uint32_t target_count;
    uint32_t total_activation_count;
    
    // Target information
    uint32_t target_addresses[MAX_GPU_TARGETS];      // Target addresses for each activation group
    uint32_t activation_counts[MAX_GPU_TARGETS];     // Number of activations per target
    uint32_t activation_offsets[MAX_GPU_TARGETS];    // Offset into flattened arrays for each target
    uint32_t target_last_activations[MAX_GPU_TARGETS]; // Pre-looked-up last activation time for each target
    float target_thresholds[MAX_GPU_TARGETS];        // Pre-looked-up thresholds for neuron targets
    
    // Flattened activation data
    float activation_values[MAX_GPU_ACTIVATIONS];        // Activation values
    uint32_t activation_timestamps[MAX_GPU_ACTIVATIONS]; // Activation timestamps  
    uint32_t source_addresses[MAX_GPU_ACTIVATIONS];      // Source addresses
    float activation_weights[MAX_GPU_ACTIVATIONS];       // Pre-looked-up weights for each activation
    
    // Processing parameters
    uint32_t current_timestamp;
    uint32_t timing_window;
    
    // Initialize to empty state
    void clear() {
        target_count = 0;
        total_activation_count = 0;
        current_timestamp = 0;
        timing_window = 10;
    }
    
    // Check if we can add more data
    bool can_add_target(uint32_t activation_count) const {
        return (target_count < MAX_GPU_TARGETS) && 
               (total_activation_count + activation_count <= MAX_GPU_ACTIVATIONS);
    }
};

// Output results from GPU processing - statically sized
struct GpuProcessingResults {
    // Number of items actually returned (runtime size)
    uint32_t firing_count;
    uint32_t soma_count;
    uint32_t new_activation_count;
    uint32_t actuator_count;
    uint32_t weight_update_count;
    
    // Neuron firing results
    uint32_t fired_neurons[MAX_GPU_TARGETS];         // Indices of neurons that fired
    float firing_intensities[MAX_GPU_TARGETS];       // Intensity of each firing
    
    // Neuron soma activations (to be processed on CPU)
    uint32_t soma_neuron_indices[MAX_GPU_TARGETS];   // Neuron indices that should be processed on CPU
    float soma_activation_levels[MAX_GPU_TARGETS];   // Activation levels for CPU processing
    uint32_t soma_target_addresses[MAX_GPU_TARGETS]; // Original target addresses for CPU processing
    
    // New activations generated by fired neurons
    uint32_t new_activations_target[MAX_GPU_OUTPUTS]; // Target addresses for new activations
    float new_activations_value[MAX_GPU_OUTPUTS];     // Values for new activations
    uint32_t new_activations_source[MAX_GPU_OUTPUTS]; // Source addresses for new activations
    uint32_t new_activations_timestamp[MAX_GPU_OUTPUTS]; // Timestamps for new activations
    
    // Actuator events
    uint32_t actuator_neurons[MAX_GPU_TARGETS];      // Indices of actuator neurons that fired
    float actuator_intensities[MAX_GPU_TARGETS];     // Intensity of actuator firings
    
    // Weight updates from Hebbian learning
    uint32_t weight_addresses[MAX_GPU_WEIGHT_UPDATES];  // Addresses of weights to update
    float weight_deltas[MAX_GPU_WEIGHT_UPDATES];        // Delta values to apply to weights
    
    // Initialize to empty state
    void clear() {
        firing_count = 0;
        soma_count = 0;
        new_activation_count = 0;
        actuator_count = 0;
        weight_update_count = 0;
    }
    
    // Check if we can add more results
    bool can_add_firing() const { return firing_count < MAX_GPU_TARGETS; }
    bool can_add_soma() const { return soma_count < MAX_GPU_TARGETS; }
    bool can_add_activation() const { return new_activation_count < MAX_GPU_OUTPUTS; }
    bool can_add_actuator() const { return actuator_count < MAX_GPU_TARGETS; }
    bool can_add_weight_update() const { return weight_update_count < MAX_GPU_WEIGHT_UPDATES; }
};

// GPU processing interface function
// This will be implemented by the GPU backend (CUDA/OpenCL/etc)
bool process_activations_gpu(const GpuActivationBatch& input, 
                            GpuProcessingResults& output);

} // namespace gpu
} // namespace neuronlib

#endif // NEURONLIB_GPU_INTERFACE_H