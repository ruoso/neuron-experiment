// OpenCL kernel for processing neural activations

// Constants from brain.h
#define MAX_GPU_TARGETS 4096
#define MAX_GPU_ACTIVATIONS 16384
#define MAX_GPU_OUTPUTS 32768
#define MAX_GPU_WEIGHT_UPDATES 8192
#define MAX_NEURONS 32768
#define DENDRITE_ADDRESS_BITS 12

// Constants from dendrite.h
#define TERMINAL_MASK 0x7
#define BRANCH_L1_MASK 0x38
#define BRANCH_L2_MASK 0x1C0
#define BRANCH_L3_MASK 0xE00
#define DENDRITE_MASK 0xFFF

// Address manipulation functions
inline bool is_terminal_address(uint target_address) {
    return (target_address & TERMINAL_MASK) != 0;
}

inline bool is_branch_address(uint target_address) {
    return (target_address & TERMINAL_MASK) == 0 && (target_address & DENDRITE_MASK) != 0;
}

inline bool is_neuron_address(uint target_address) {
    return (target_address & DENDRITE_MASK) == 0;
}

inline uint get_terminal_branch(uint terminal_address) {
    return terminal_address & ~TERMINAL_MASK;
}

inline uint get_parent_branch(uint branch_address) {
    if ((branch_address & BRANCH_L1_MASK) != 0) {
        return branch_address & ~BRANCH_L1_MASK;
    } else if ((branch_address & BRANCH_L2_MASK) != 0) {
        return branch_address & ~BRANCH_L2_MASK;
    } else if ((branch_address & BRANCH_L3_MASK) != 0) {
        return branch_address & ~BRANCH_L3_MASK;
    }
    return branch_address;
}

inline uint get_neuron_address(uint dendrite_address) {
    return dendrite_address & ~DENDRITE_MASK;
}

// Input batch structure (must match C++ struct)
typedef struct {
    uint target_count;
    uint total_activation_count;
    
    // Target information
    uint target_addresses[MAX_GPU_TARGETS];
    uint activation_counts[MAX_GPU_TARGETS];
    uint activation_offsets[MAX_GPU_TARGETS];
    uint target_last_activations[MAX_GPU_TARGETS];
    float target_thresholds[MAX_GPU_TARGETS];
    
    // Flattened activation data
    float activation_values[MAX_GPU_ACTIVATIONS];
    uint activation_timestamps[MAX_GPU_ACTIVATIONS];
    uint source_addresses[MAX_GPU_ACTIVATIONS];
    float activation_weights[MAX_GPU_ACTIVATIONS];
    
    // Processing parameters
    uint current_timestamp;
    uint timing_window;
} GpuActivationBatch;

// Output results structure (must match C++ struct)
typedef struct {
    uint firing_count;
    uint soma_count;
    uint new_activation_count;
    uint actuator_count;
    uint weight_update_count;
    
    // Neuron firing results
    uint fired_neurons[MAX_GPU_TARGETS];
    float firing_intensities[MAX_GPU_TARGETS];
    
    // Neuron soma activations (to be processed on CPU)
    uint soma_neuron_indices[MAX_GPU_TARGETS];
    float soma_activation_levels[MAX_GPU_TARGETS];
    uint soma_target_addresses[MAX_GPU_TARGETS];
    
    // New activations generated by fired neurons
    uint new_activations_target[MAX_GPU_OUTPUTS];
    float new_activations_value[MAX_GPU_OUTPUTS];
    uint new_activations_source[MAX_GPU_OUTPUTS];
    uint new_activations_timestamp[MAX_GPU_OUTPUTS];
    
    // Actuator events
    uint actuator_neurons[MAX_GPU_TARGETS];
    float actuator_intensities[MAX_GPU_TARGETS];
    
    // Weight updates from Hebbian learning
    uint weight_addresses[MAX_GPU_WEIGHT_UPDATES];
    float weight_deltas[MAX_GPU_WEIGHT_UPDATES];
} GpuProcessingResults;

__kernel void process_activations_kernel(
    __global const GpuActivationBatch* input,
    __global GpuProcessingResults* output
) {
    int target_idx = get_global_id(0);
    
    if (target_idx >= input->target_count) {
        return;
    }
    
    uint target_address = input->target_addresses[target_idx];
    uint activation_count = input->activation_counts[target_idx];
    uint activation_offset = input->activation_offsets[target_idx];
    uint current_timestamp = input->current_timestamp;
    uint timing_window = input->timing_window;
    
    // Process activations within timing window
    float total_input = 0.0f;
    float total_absolute_weights = 0.0f;
    
    for (uint i = 0; i < activation_count; ++i) {
        uint act_idx = activation_offset + i;
        
        if (act_idx >= MAX_GPU_ACTIVATIONS) break;
        
        uint timestamp = input->activation_timestamps[act_idx];
        
        // Check if activation is within timing window
        if (current_timestamp >= timestamp && 
            current_timestamp <= timestamp + timing_window) {
            
            float value = input->activation_values[act_idx];
            float weight = input->activation_weights[act_idx];
            
            float weighted_input = value * weight;
            total_input += weighted_input;
            total_absolute_weights += fabs(weight);
        }
    }
    
    // Normalize output to 0-1 range based on total absolute weights
    if (total_absolute_weights > 0.0f) {
        total_input = (total_input + total_absolute_weights) / (2.0f * total_absolute_weights);
        total_input = fmax(0.0f, fmin(1.0f, total_input));
    }
    
    // Check if this is a neuron address
    if (is_neuron_address(target_address)) {
        uint neuron_index = target_address >> DENDRITE_ADDRESS_BITS;
        
        if (neuron_index < MAX_NEURONS) {
            float threshold = input->target_thresholds[target_idx];
            bool neuron_fired = total_input >= threshold;
            
            // Check refractory period
            const uint REFRACTORY_PERIOD = 5;
            uint last_firing_time = input->target_last_activations[target_idx];
            bool in_refractory = (current_timestamp - last_firing_time) < REFRACTORY_PERIOD;
            
            if (neuron_fired && in_refractory) {
                neuron_fired = false;
            }
            
            // Add soma activation for CPU processing (regardless of firing)
            uint soma_idx = atomic_inc(&output->soma_count);
            if (soma_idx < MAX_GPU_TARGETS) {
                output->soma_neuron_indices[soma_idx] = neuron_index;
                output->soma_activation_levels[soma_idx] = total_input;
                output->soma_target_addresses[soma_idx] = target_address;
            }
            
            // Apply Hebbian learning - weight updates
            const float LEARNING_RATE = 0.01f;
            for (uint i = 0; i < activation_count; ++i) {
                uint act_idx = activation_offset + i;
                if (act_idx >= MAX_GPU_ACTIVATIONS) break;
                
                uint timestamp = input->activation_timestamps[act_idx];
                if (current_timestamp >= timestamp && 
                    current_timestamp <= timestamp + timing_window) {
                    
                    uint source_address = input->source_addresses[act_idx];
                    float value = input->activation_values[act_idx];
                    float weight = input->activation_weights[act_idx];
                    float weighted_input = value * weight;
                    
                    float delta = 0.0f;
                    if (neuron_fired && weighted_input > 0.0f) {
                        // Strengthen weights that contributed to firing
                        delta = LEARNING_RATE * value;
                    } else if (!neuron_fired) {
                        // Slightly weaken weights when neuron doesn't fire
                        delta = -LEARNING_RATE * 0.1f;
                    }
                    
                    if (delta != 0.0f) {
                        uint weight_idx = atomic_inc(&output->weight_update_count);
                        if (weight_idx < MAX_GPU_WEIGHT_UPDATES) {
                            output->weight_addresses[weight_idx] = source_address;
                            output->weight_deltas[weight_idx] = delta;
                        }
                    }
                }
            }
        }
    } else if (is_terminal_address(target_address)) {
        // Terminal: propagate to its branch
        uint branch_address = get_terminal_branch(target_address);
        if (total_input > 0.0f) {
            uint new_act_idx = atomic_inc(&output->new_activation_count);
            if (new_act_idx < MAX_GPU_OUTPUTS) {
                output->new_activations_target[new_act_idx] = branch_address;
                output->new_activations_value[new_act_idx] = total_input;
                output->new_activations_source[new_act_idx] = target_address;
                output->new_activations_timestamp[new_act_idx] = current_timestamp;
            }
        }
    } else if (is_branch_address(target_address)) {
        // Branch: propagate to parent
        uint parent_address = get_parent_branch(target_address);
        
        // Intermediate branch - propagate to parent
        if (total_input > 0.0f) {
            uint new_act_idx = atomic_inc(&output->new_activation_count);
            if (new_act_idx < MAX_GPU_OUTPUTS) {
                output->new_activations_target[new_act_idx] = parent_address;
                output->new_activations_value[new_act_idx] = total_input;
                output->new_activations_source[new_act_idx] = target_address;
                output->new_activations_timestamp[new_act_idx] = current_timestamp;
            }
        }
    }
}